Operator Interface Specification (version: 3)

HARD RULES
1. When outputting OPERATOR_CMD blocks, output ONLY plain text (no markdown, no bullet lists, no indentation-based formatting, no surrounding prose).
2. Marker lines MUST be alone on their own line (surrounding whitespace allowed): OPERATOR_CMD, END_OPERATOR_CMD, OPERATOR_RESULT, END_OPERATOR_RESULT.
3. Inside OPERATOR_CMD blocks, ONLY lines of the form "key: value" are allowed (one key-value per line; keys are case-sensitive). Any other non-empty line makes the command invalid.
4. OPERATOR_CMD blocks MUST NOT be nested. If START appears before END, the block is invalid.
5. Multi-line payloads MUST NEVER be sent inline. Use base64 UTF-8 fields: content_b64, patch_b64, edits_b64.
   Base64 fields MUST be a single line with no whitespace; only A-Z a-z 0-9 + / = are allowed, and padding must be correct.
6. The plain "content" field MAY be used ONLY for very small single-line text and MUST NOT contain line breaks.
7. Use ASCII only inside OPERATOR_CMD blocks. Non-ASCII characters make the command invalid.
8. Every OPERATOR_CMD MUST include: version: 1, id: <string>, action: <string>. version must be exactly 1.
9. The command id MUST be echoed verbatim in the corresponding OPERATOR_RESULT.
10. Actions starting with "fs." REQUIRE a path field. Actions not starting with "fs." MUST NOT include a path field.
11. Workspace is NOT part of OPERATOR_CMD. Do NOT include workspace/workspaceRoot (or any equivalent) as a command field. Workspace is selected in the app UI and stored as state.
12. Do NOT guess file contents. Read before modifying. Do not issue fs.patch or fs.applyEdits without reading relevant context first.
13. fs.patch is strict unified diff patching; hunks and context must match exactly or the command fails.
14. Never claim a side effect (write/edit/delete) succeeded unless a corresponding OPERATOR_RESULT with ok: true has been received for that command id.
15. If there is no OPERATOR_RESULT for a command id, treat the command as not executed.
16. Only OPERATOR_CMD blocks in the assistantâ€™s normal message stream are considered commands. Any tool/internal output is not a command.
17. After any successful write/edit/delete (ok: true), immediately verify the change using fs.readSlice and quote the relevant affected lines before claiming success.

MARKERS (each marker must be on its own line)
OPERATOR_CMD
END_OPERATOR_CMD
OPERATOR_RESULT
END_OPERATOR_RESULT

OPERATOR_CMD FORMAT
OPERATOR_CMD
version: 1
id: <string>
action: <string>
(optional additional key: value lines)
END_OPERATOR_CMD

OPERATOR_RESULT FORMAT
OPERATOR_RESULT
id: <same id as command>
ok: true|false
summary: <short single-line summary>
details_b64: <optional base64 UTF-8 payload>
END_OPERATOR_RESULT

ERROR CODES (parser/validator)
Invalid command summaries use:
Invalid OPERATOR_CMD (ERR_...): <what to fix>

Core errors:
- ERR_MARKER_NOT_ALONE
- ERR_MISSING_END_MARKER
- ERR_NESTED_BLOCK
- ERR_NON_KEY_VALUE_LINE
- ERR_EMPTY_LINE_IN_CMD
- ERR_NON_ASCII_IN_CMD
- ERR_MISSING_REQUIRED_FIELDS
- ERR_ACTION_REQUIRES_PATH
- ERR_ACTION_FORBIDS_PATH
- ERR_CONTENT_HAS_NEWLINES
- ERR_INVALID_BASE64
- ERR_SEARCH_PATH_IS_DIR

Additional validation errors:
- ERR_MISSING_QUERY
- ERR_INVALID_READSLICE_PARAMS
- ERR_MISSING_EDITS_B64
- ERR_MISSING_PATCH_B64
- ERR_INVALID_EDITS_JSON
- ERR_UNKNOWN_ACTION
- ERR_RESERVED_ACTION
- ERR_DUPLICATE_ID
- ERR_BLOCK_TOO_LARGE
- ERR_UNSUPPORTED_VERSION
- ERR_FILE_TOO_LARGE
- ERR_MISSING_MARKER_ID
- ERR_MISSING_CONTENT_B64
- ERR_MISSING_WRITE_CONTENT
- ERR_UNKNOWN_LANGUAGE
- ERR_COMMENT_STYLE_REQUIRED
- ERR_INVALID_COMMENT_STYLE
- ERR_REGION_MARKER_NOT_FOUND
- ERR_REGION_MARKER_NOT_UNIQUE
- ERR_REGION_MARKER_ORDER
- ERR_REGION_MARKER_MISMATCH
- ERR_REGION_MARKER_ALREADY_EXISTS
- ERR_MISSING_ANCHOR
- ERR_ANCHOR_NOT_FOUND
- ERR_INVALID_ANCHOR_OCCURRENCE
- ERR_INVALID_INSERT_POSITION

ACTIONS

operator.getInterfaceSpec
Required: version, id, action
No path allowed
Result: details_b64 contains this interface specification (base64 UTF-8)

operator.getCommentStyle
Required: version, id, action
No path allowed
Optional: language (e.g., "ts", "python", "html")
Result: details_b64 contains JSON describing comment styles.
If language is provided, the payload is a single style object:
- {"language":"<id>","type":"line","line_prefix":"//"}
- {"language":"<id>","type":"block","block_start":"<!--","block_end":"-->"}
The "language" field uses the resolved mapping key (e.g., "ts" for "typescript").
If language is omitted, returns {"styles":[...]} with all supported default mappings.

operator.error
Required: version, id, action
No path allowed
Purpose: UI-generated error feedback (e.g., scan/validation failures). This is NOT an execution result for any other command.
Result: details_b64 contains JSON {"message":"<error message>","related_id":"<optional original command id>"}.
LLM behavior: treat as an error report; do NOT assume any command was executed.
LLMs MUST NOT emit operator.error; it is UI-generated only.
If an OPERATOR_CMD attempts operator.error, it is rejected with ERR_RESERVED_ACTION.
LLM expectation:
- When an error relates to a specific command, related_id will be that command id.
- The OPERATOR_RESULT id for such an error will match related_id so you can associate it with the failed command.

FILESYSTEM ACTIONS (fs.*)
All fs.* actions operate strictly within the currently selected workspace root.
Write/edit/patch/delete actions require explicit user confirmation.
Paths are always interpreted as relative to the workspace root.

fs.list
Requires: path (directory)
Result: details_b64 contains directory entries, one per line

fs.read
Requires: path (file)
Result: details_b64 contains full file content (base64 UTF-8)
Size limit: 200000 bytes.
If file exceeds size limits, returns ok:false with summary:
"File too large for fs.read (<bytes> bytes). Use fs.readSlice."

fs.readSlice
Requires: path (file)
Params: start (1-based line, default 1); lines (default 120, max 400)
Aliases: line/from for start; count/len for lines
Result: details_b64 contains header lines starting with "#" plus numbered lines
Size limit: 2000000 bytes.
If file exceeds size limits, returns ERR_FILE_TOO_LARGE.

fs.search
Requires: path (file)
Params: query (required substring)
Aliases: q
Result: details_b64 contains header lines starting with "#" plus matching lines with line numbers
Results are capped at 50 matches; header includes "(truncated)" when clipped.
Size limit: 2000000 bytes.
If file exceeds size limits, returns ERR_FILE_TOO_LARGE.

fs.stat
Requires: path
Result: details_b64 contains JSON: {path,size,isFile,isDir,mtimeMs,ctimeMs}

fs.searchTree
Requires: path (file or directory)
Params: query (required substring)
Aliases: q
Result: details_b64 contains header lines starting with "#" plus matches in the form "<path>:<line>: <text>"
Limits: max 200 matches, max 300 files scanned, skip files over 500000 bytes.
Results may be truncated.

fs.listRegions
Requires: path
Optional: comment_line_prefix or comment_block_start/comment_block_end or language
Result: details_b64 contains JSON object {"regions":[...]} with marker_id and line ranges

REGION MARKERS (for read/replace/delete region)
Markers are comment lines inside files:
- OPERATOR_BEGIN <marker_id>
- OPERATOR_END <marker_id>

The comment style defaults to a language mapping based on file extension.
Overrides per command:
- comment_line_prefix: <string>        (e.g., "//" or "#")
- comment_block_start: <string>        (e.g., "/*" or "<!--")
- comment_block_end: <string>          (e.g., "*/" or "-->")
- language: <string>                   (explicit mapping; optional)

Region rules and guidance:
- marker_id should be unique per file; do not reuse the same marker_id.
- Do not nest or overlap regions; keep markers paired and ordered.
- Prefer regions for incremental edits in code/text files.
- Use fs.listRegions to discover existing regions.
- Use fs.insertRegion to create a new region around new content.
- When comment style is unknown, call operator.getCommentStyle or pass explicit comment_* overrides.
- Choose anchors that are stable and specific; if multiple matches exist, use occurrence.

Examples:
// OPERATOR_BEGIN section-1
// OPERATOR_END section-1

<!-- OPERATOR_BEGIN section-1 -->
<!-- OPERATOR_END section-1 -->

fs.readRegion
Requires: path
Requires: marker_id
Optional: comment_line_prefix or comment_block_start/comment_block_end or language
Result: details_b64 contains the content between markers (base64 UTF-8)

fs.insertRegion
Requires: path
Requires: marker_id
Requires: anchor
Requires: content_b64 (base64 UTF-8)
Optional: position: before|after (default after)
Optional: occurrence: <number> (default 1)
Optional: comment_line_prefix or comment_block_start/comment_block_end or language
Behavior: inserts a new marker block near anchor and writes content between markers

fs.replaceRegion
Requires: path
Requires: marker_id
Requires: content_b64 (base64 UTF-8)
Optional: comment_line_prefix or comment_block_start/comment_block_end or language
Behavior: replaces lines between markers, preserves the marker lines

fs.deleteRegion
Requires: path
Requires: marker_id
Optional: comment_line_prefix or comment_block_start/comment_block_end or language
Behavior: removes lines between markers, preserves the marker lines

fs.write
Requires: path
Requires: content_b64 or content
Requires user confirmation
Payload: content_b64 (preferred, base64 UTF-8, multi-line allowed) OR content (single-line only)
Behavior: overwrites or creates the file
If payload is missing, returns ERR_MISSING_WRITE_CONTENT.

fs.patch
Requires: path
Requires user confirmation
Payload: patch_b64 (base64 UTF-8 unified diff)
Behavior: strict unified diff for a single file; supports @@ -a,b +c,d @@ hunks; context must match exactly

fs.applyEdits
Requires: path
Requires user confirmation
Payload: edits_b64 (base64 UTF-8 JSON)
Decoded JSON format: {"version":1,"edits":[...]}
Edit objects (op): insertAfter, insertBefore, replaceFirst, replaceAll, replaceRange.
For insert*: anchor (string), text (string), optional occurrence (number>=1).
For replace*: find (string), text (string).
For replaceRange: startLine (1-based), endLine (1-based), text (string).
Behavior note: for insertAfter, if the anchor ends a line and text does not start with "\n", Operator will prepend "\n".
Strict semantics: first failure aborts and no changes are written.

fs.delete
Requires: path
Requires user confirmation
Behavior: deletes or trashes the path

RECOMMENDED WORKFLOW
1) operator.getInterfaceSpec (once at the start of a session)
2) fs.search
3) fs.readSlice
4) fs.applyEdits (preferred) or fs.patch (single-hunk, minimal context)
5) fs.readSlice (verification after any write/edit)
- Avoid fs.read unless the file is small.
- For incremental edits in code/text files, prefer regions:
  a) fs.listRegions
  b) fs.readRegion (when content is needed)
  c) fs.insertRegion / fs.replaceRegion / fs.deleteRegion

LLM GUIDANCE
- Keep OPERATOR_CMD blocks short: max 200 lines and 50,000 chars inside a block.
- Use unique ids per command; duplicate ids with identical content are ignored, differing content returns ERR_DUPLICATE_ID.
- Place OPERATOR_CMD blocks near the end of the message; only the last 200,000 chars are scanned.
- Use fs.readSlice for large files; fs.read can fail with a size limit.
- fs.search returns at most 50 matches; refine the query if results are truncated.
- Base64 payloads must be single-line (no whitespace). On ERR_INVALID_BASE64, re-encode and retry; split large payloads.
- Choose conservative payload sizes to reduce base64 encoding errors; split very large content into multiple edits or regions.

GOLDEN PATH EXAMPLES
fs.write (content_b64):
OPERATOR_CMD
version: 1
id: write-001
action: fs.write
path: notes/plan.txt
content_b64: QWxwaGEKQmV0YQ==
END_OPERATOR_CMD

fs.applyEdits (edits_b64):
OPERATOR_CMD
version: 1
id: edits-001
action: fs.applyEdits
path: notes/plan.txt
edits_b64: eyJ2ZXJzaW9uIjoxLCJlZGl0cyI6W3sib3AiOiJpbnNlcnRBZnRlciIsImFuY2hvciI6IkJldGEiLCJ0ZXh0IjoiXG5HYW1tYSJ9XX0=
END_OPERATOR_CMD

COMMON MISTAKE EXAMPLE
If content has multiple lines in "content", it will be rejected:
Invalid OPERATOR_CMD (ERR_CONTENT_HAS_NEWLINES): content contains newline; use content_b64.
